"""Functions related to the Sychronous NIMBUS method.

References:
    Miettinen, K., & Mäkelä, M. M. (2006). Synchronous approach in interactive
        multiobjective optimization. European Journal of Operational Research,
        170(3), 909–922.
"""

import numpy as np

from desdeo.problem import Problem, VariableType, variable_dict_to_numpy_array, GenericEvaluator
from desdeo.tools import (
    CreateSolverType,
    SolverOptions,
    SolverResults,
    add_asf_diff,
    add_asf_nondiff,
    add_nimbus_sf_diff,
    add_nimbus_sf_nondiff,
    add_stom_sf_diff,
    add_stom_sf_nondiff,
    add_guess_sf_diff,
    add_guess_sf_nondiff,
    guess_best_solver,
)


class NimbusError(Exception):
    """Raised when an error with a NIMBUS method is encountered."""


def solve_intermediate_solutions(
    problem: Problem,
    solution_1: dict[str, VariableType],
    solution_2: dict[str, VariableType],
    num_desired: int,
    create_solver: CreateSolverType | None = None,
    solver_options: SolverOptions | None = None,
) -> list[dict[str, VariableType | float]]:
    """Generates a desired number of intermediate solutions between two given solutions.

    Generates a desires number of intermediate solutions given two Pareto optimal solutions.
    The solutions are generated by taking n number of steps between the two solutions in the
    objective space. The objective vectors corresponding to these solutions are then
    utilized as reference points in the achievement scalarizing function. Solving the functions
    for each reference point will project the reference point on the Pareto optimal
    front of the problem. These projected solutions are then returned. Note that the
    intermediate solutions are generated _between_ the two given solutions, this means the
    returned solutions will not include the original points.

    Args:
        problem (Problem): the problem being solved.
        solution_1 (dict[str, VariableType]): the first of the solutions between which the intermediate
            solutions are to be generated.
        solution_2 (dict[str, VariableType]): the second of the solutions between which the intermediate
            solutions are to be generated.
        num_desired (int): the number of desired intermediate solutions to be generated. Must be at least `1`.
        create_solver (CreateSolverType | None, optional): a function that given a problem, will return a solver.
            If not given, an appropriate solver will be automatically determined based on the features of `problem`.
            Defaults to None.
        solver_options (SolverOptions | None, optional): optional options passed
            to the `create_solver` routine. Ignored if `create_solver` is `None`.
            Defaults to None.

    Returns:
        list[dict[str, VariableType | float]]: a list with the projected intermediate solutions, including
            the decision variable values and the respective objective functions values. Each element is a dict
            with keys corresponding to the symbols of the decision variables and objective functions defined
            for the given `problem`.
    """
    if int(num_desired) < 1:
        msg = f"The given number of desired intermediate ({num_desired=}) solutions must be at least 1."
        raise NimbusError(msg)

    _create_solver = guess_best_solver(problem) if create_solver is None else create_solver
    _solver_options = None if solver_options is None else solver_options

    # compute the element-wise difference between each solution (in the decision space)
    solution_1_arr = variable_dict_to_numpy_array(problem, solution_1)
    solution_2_arr = variable_dict_to_numpy_array(problem, solution_2)
    delta = solution_1_arr - solution_2_arr

    # the '2' is in the denominator because we want to calculate the steps
    # between the two given points; we are not interested in the given points themselves.
    step_size = delta / (2 + num_desired)

    intermediate_points = np.array([solution_2_arr + i * step_size for i in range(1, num_desired + 1)])

    xs = {f"{variable.symbol}": intermediate_points[:, i].tolist() for (i, variable) in enumerate(problem.variables)}

    # evaluate the intermediate points to get reference points
    # TODO(gialmisi): an evaluator might have to be selected depending on the problem
    evaluator = GenericEvaluator(problem)

    reference_points: list[dict[str, float]] = (
        evaluator.evaluate(xs).select([obj.symbol for obj in problem.objectives]).to_dicts()
    )

    # for each reference point, add and solve the ASF scalarization problem
    # projecting the reference point onto the Pareto optimal front of the problem.
    # TODO(gialmisi): this can be done in parallel.
    intermediate_solutions = []
    for rp in reference_points:
        # add scalarization
        # TODO(gialmisi): add logic that selects correct variant of the ASF
        # depending on problem properties (either diff or non-diff)
        asf_problem, target = add_asf_nondiff(problem, "target", rp, reference_in_aug=False)

        solver = _create_solver(asf_problem, _solver_options)

        # solve and store results
        result: SolverResults = solver(target)

        intermediate_solutions.append(result.optimal_variables | result.optimal_objectives)

    return intermediate_solutions
