"""Functions related to the Sychronous NIMBUS method.

References:
    Miettinen, K., & Mäkelä, M. M. (2006). Synchronous approach in interactive
        multiobjective optimization. European Journal of Operational Research,
        170(3), 909–922.
"""

import numpy as np

from desdeo.problem import Problem, VariableType, variable_dict_to_numpy_array
from desdeo.tools import (
    CreateSolverType,
    add_asf_diff,
    add_asf_nondiff,
    add_nimbus_sf_diff,
    add_nimbus_sf_nondiff,
    add_stom_sf_diff,
    add_stom_sf_nondiff,
    add_guess_sf_diff,
    add_guess_sf_nondiff,
    guess_best_solver,
)


class NimbusError(Exception):
    """Raised when an error with a NIMBUS method is encountered."""


def solve_intermediate_solutions(
    problem: Problem,
    solution_1: dict[str, VariableType],
    solution_2: dict[str, VariableType],
    num_desired: int,
    create_solver: CreateSolverType | None = None,
) -> list[dict[str, VariableType | float]]:
    """Generates a desired number of intermediate solutions between two given solutions.

    Generates a desires number of intermediate solutions given two Pareto optimal solutions.
    The solutions are generated by taking n number of steps between the two solutions in the
    objective space. The objective vectors corresponding to these solutions are then
    utilized as reference points in the achievement scalarizing function. Solving the functions
    for each reference point will project the reference point on the Pareto optimal
    front of the problem. These projected solutions are then returned. Note that the
    intermediate solutions are generated _between_ the two given solutions, this means the
    returned solutions will not include the original points.

    Args:
        problem (Problem): the problem being solved.
        solution_1 (dict[str, VariableType]): the first of the solutions between which the intermediate
            solutions are to be generated.
        solution_2 (dict[str, VariableType]): the second of the solutions between which the intermediate
            solutions are to be generated.
        num_desired (int): the number of desired intermediate solutions to be generated. Must be at least `1`.
        create_solver (CreateSolverType | None, optional): a function that given a problem, will return a solver.
            If not given, an appropriate solver will be automatically determined based on the features of `problem`.
            Defaults to None.

    Returns:
        list[dict[str, VariableType | float]]: a list with the projected intermediate solutions, including
            the decision variable values and the respective objective functions values. Each element is a dict
            with keys corresponding to the symbols of the decision variables and objective functions defined
            for the given `problem`.
    """
    if int(num_desired) < 1:
        msg = f"The given number of desired intermediate ({num_desired=}) solutions must be at least 1."
        raise NimbusError(msg)

    # compute the element-wise difference between each solution (in the decision space)
    solution_1_arr = variable_dict_to_numpy_array(problem, solution_1)
    solution_2_arr = variable_dict_to_numpy_array(problem, solution_2)
    delta = solution_1_arr - solution_2_arr
